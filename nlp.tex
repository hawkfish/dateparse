\subsection{Context-Free Grammar}
ICU date-time formats are well defined both structurally and semantically, and can be defined by a context-free grammar (CFG). A CFG is commonly defined as a set of productions or rules of the form A ? ? where A is a variable, ? is a sequence of variables and terminal symbols (the tokens that make up the alphabet of the language) plus null (? ), and the production symbol (?) indicates that the variable A can be expanded into ? . A CFG can be formally specified with four components: V, T, P, and S, where V is the set of variables, T the set of terminal symbols, P the set of productions, and S the set of available start symbols (a non-empty subset of V) [cite]. 

While there are several functionally equivalent notations for representing CFG, we use the \textit{Backus-Naur Form} (BNF) for defining the grammar rules for \dateparse formats. In particular, we use the \textit{Extended Backus-Naur Form} (EBNF) as the notation is more compact and readable for frequently used constructions~\cite{Grune:1990}. 

We define a grammar for identifying date-time strings based on other EBNF based date-time formats [cite] as a reference. A partial definition of the grammar is found below (see supplementary material for complete definition):

\begin{grammar}
<TimeGrammar> ::= <Hours> ':' <Minutes> ':' <Seconds> <AMPM>;\\

<DateGrammar> ::= <BigEndianDate> 
				\alt <MiddleEndianDate> 
				\alt <LittleEndianDate>;

<DateTimeGrammar>  ::= <DateGrammar> 
					\alt <TimeGrammar>;
					
<AMPM>  ::=  WORD('a.m.') 
			 \alt WORD('p.m.') ;

<Year> ::= <TwoYear> | <FourYear>;

<Month>  ::= <MonthFullForm> | <MonthAbbrForm> | <MonthLetterForm> | <MonthNumber>;

<BigEndianDate> ::= <Year> <Month>  <Day> ;

<MiddleEndianDate> ::= <Month> <Day> <Year>;

<LittleEndianDate> ::= <Day> <Month> <Year>;

\end{grammar}



\subsection{Translation of Grammar Output to ICU Format}

\subsection{Production Rule Constraints and Variants}

The EBNF date-time grammar includes a large number of syntactically correct but semantically invalid
date-time expressions. For example, there is no  `November 31, 2015', `February 29, 2013',
or `Sunday, May  5, 1965'. November only as 30 days in any year; 2013 was not a leap year; and May 5, 1965 was a Wednesday.

While custom production rules can be added to the existing grammar to exclude such expressions, this approach is not optimal as it leads to a rather large grammar that needs to account for every single semantically valid date-time sequence of terminal symbols. Rather, we define a grammar that excludes such expressions. By intersecting this constraint
grammar with the Date-Time grammar, we can define a language that contains only semantically valid dates.



\subsection{Probabilistic Context-Free Grammar}
Pattern-recognition problems such as parsing date and time formats initiate from observations generated by some structured stochastic process. In other words, even if the initial higher-level production rule of the grammar is known (i.e. date, time or date-time), there could be several directions that the parser resolve to. For example, in a date string 5/6/2015, the pattern could either be M/d/yyyy or d/M/yyyy. 

Probabilistic context-free grammars (PCFGs) have provided a useful method for modeling such uncertainty [cite]. Once we have created a PCFG model of a process, we can apply existing PCFG parsing algorithms to identify a variety of date-time formats. However, the parser’s success is often limited in the types of the dominant patterns that it can identify. In addition, the standard parsing techniques generally require specification of a complete observation sequence. In many contexts, we may have only a partial sequence available (e.g. an incomplete entry). Finally, we may be interested in computing the probabilities of date-time patterns that the grammar may not explicitly define. To extend the forms of evidence, inferences, and pattern distributions supported, we need a flexible and expressive representation for the distribution of structures generated by the grammar. We adopt Bayesian networks for this purpose, and define an algorithm to generate a probabilistic distribution of possible parse trees corresponding to a set of date-time patterns as opposed to individual ones. 



%•	Motivate the use of context-free grammar, particularly Backus-Normal-Form
%•	Explain why we use a probabilistic version of the grammar
%•	Explain how the production rules are created based on the ICU format
%•	Extensions to the parser to account for columnar context for maximizing the probabilistic occurrence of the dominant pattern
%•	Other semantic extensions – looking at the file name, adding rules for leap year, using external dictionaries for non-English terms
